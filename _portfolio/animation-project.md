---
title: Animation Project
role: Graphics Programmer
image: assets/image-sample.png
alt: Animation Project
categories: C++ OpenGL GLSL
asset-base: /assets/programming/animation/
tags: graphics

priority : 3

caption:
  title: Animation Project
  subtitle: Skeletal Animation <br> Motion along a Path <br> Inverse Kinematics <br> Physically-based Simulation
  thumbnail: /assets/programming/animation/thumbnail.png

video:
  title: Video
  url: https://www.youtube.com/embed/rOjF9nAoKrk
  detail:
    title: "Four scenes for demonstrating animation"
    desc: "1. Hierarchical Modeling and Animation<br>2. Motion along a Path<br>3. Inverse Kinematics<br>4. Physically-based Simulation"

scene1:
  - image-path: animation.png
    alt: animated characters
    desc: skinning
  - image-path: bone.png
    alt: characters's bone
    desc: bone for skeletal animation
detail:
  - image-path: curve.png
    alt: motion along a path
    desc: speed control and animation blending
  - image-path: ik-start.png
    alt: begin IK
    desc: begin IK
  - image-path: ik-middle.png
    alt: end IK
    desc: end IK
  - image-path: cloth.png
    alt: cloth simulation
    desc: cloth simulation
---
<hr/>

{% include custom/section-header title="[Scene 1] Hierarchical Modeling and Animation" %}

{% include custom/gallery id="scene1" %}
This scene demonstrates skinned mesh animation using OpenGL. The animated 3d characters for the project are from Mixamo.
The object and animation key frame use quaternion and VQS to store their transform data. The character is animated by key frames uses incremental VQS interpolation (iVQS) method to interpolation between two key frames.
VQS has quaternion with translation and uniform scaling factor. VQS is used for the project because it has no Gimbal lock problem, is efficient for concatenations, and allows separate interpolation algorithms. The iVQS approach improves the flaws that VQS are more expensive than matrix transformation.


{% include custom/section-header title="[Scene 2] Motion along a Path" %}
{% include custom/image image-path="curve.png" alt="motion along a path" desc="speed control and animation blending" %}
In this scene, the character moves along the path at different speeds and uses Center of Interest approach for orientation control.
The distance-time function S(t) can be derived from the user-defined velocity function V(t) where t is the time between 0 and 1. The current distance is the value obtained by substituting the current time into S(t). Then, the interpolant parameter u can be found using the inverse arc length function; u=Inverse-G(S(t)). The arc length table is generated using an adaptive approach. The current position can be obtained by putting u to the interpolated Bezier curve function generated by given control points’ positions. 
The program supports animation blending so that the character’s animation varies with its speed. And the user can change the speed range at which to blend animation (Idle <-> Walk <-> Run).


{% include custom/section-header title="[Scene 3] Inverse Kinematics" %}
{% include custom/image image-path="ik-start.png" alt="begin IK" desc="begin IK" %}
{% include custom/image image-path="ik-middle.png" alt="end IK" desc="end IK" %}
If the user sets the destination to go, the stick character moves to the target. Once the character arrives at the destination, it will grab a ball item using Cyclic Coordinate Descent, one of the inverse kinematic algorithms. It calculates how much each link should be rotated in order for the end-effector to be located at the target position.

{% include custom/section-header title="[Scene 4] Physically-based Simulation" %}
{% include custom/image image-path="cloth.png" alt="cloth simulation" desc="cloth simulation" %}
This is a scene for the cloth simulation to express cloth behavior by following the fundamental concept of physics. The project uses 50x50 particles for 2x2 sized cloth. The cloth is affected by wind and gravity and avoid the ball in the middle.
